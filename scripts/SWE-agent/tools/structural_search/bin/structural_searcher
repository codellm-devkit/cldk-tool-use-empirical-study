#!/usr/bin/env python3
"""Structural Searcher Tool
================================================
Structure‑aware search for SWE‑Agent.

Commands
--------
* `find_file`     – search for a filename or module path under a directory.
* `search_entity` – search for a class/function/method in a file.
* `find_code`     – locate function/method blocks that contain a code snippet.

These commands reuse previous analysis when possible for efficiency.
"""
from __future__ import annotations

import argparse
import hashlib
import json
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List

MAX_RESPONSE_LEN = 16000
TRUNCATED_MESSAGE = (
    "<response clipped><NOTE>To save on context, only part of the code has been "
    "shown. Use `str_replace_editor view --view_range` to inspect full block.</NOTE>"
)


# ---------------------------------------------------------------------------
# Command: find_file
# ---------------------------------------------------------------------------
def find_file(query: str, directory: Path) -> str:
    """Find matching Python files from a name or module path (e.g. utils or a.b.c)."""
    potential_names = {query}
    if not query.endswith(".py"):
        potential_names.add(query + ".py")
        if "." in query:
            mod_path = Path(*query.split("."))
            potential_names.add(str(mod_path.with_suffix(".py")))

    matches = []
    for name in potential_names:
        matches.extend(directory.rglob(name))

    matches = sorted(p for p in set(matches))
    if not matches:
        return f"<ERROR>No match for `{query}` found in `{directory}`.</ERROR>"
    return "Found the following paths:\n" + "\n".join(str(m) for m in matches)


# ---------------------------------------------------------------------------
# Command: search_entity
# ---------------------------------------------------------------------------
def search_entity(file_path: Path, entity: str) -> str:
    symbol_table = run_codeanalyzer_on_file(file_path)
    key = get_best_key(symbol_table, file_path)
    mod = symbol_table.get(key)
    if not mod:
        return f"<ERROR>Could not locate module info for `{file_path}`.</ERROR>"

    for fn in mod.get("functions", {}).values():
        if fn["name"] == entity:
            return format_code_block(fn["code"], fn["start_line"], fn["end_line"], descriptor=entity)

    for cls in mod.get("classes", {}).values():
        if cls["name"] == entity:
            header = format_code_block(cls["code"], cls["start_line"], cls["end_line"], descriptor=entity)
            methods = [
                format_code_block(m["code"], m["start_line"], m["end_line"], descriptor=f"{entity}.{mname}")
                for mname, m in cls.get("methods", {}).items()
            ]
            return header + "\n\n" + "\n\n".join(methods)
        for mname, m in cls.get("methods", {}).items():
            if mname == entity or f"{cls['name']}.{mname}" == entity:
                return format_code_block(m["code"], m["start_line"], m["end_line"], descriptor=f"{cls['name']}.{mname}")

    return f"<ERROR>Entity `{entity}` not found in `{file_path.name}`.</ERROR>"


# ---------------------------------------------------------------------------
# Command: find_code
# ---------------------------------------------------------------------------
def find_code(file_path: Path, snippet: str) -> str:
    norm = lambda s: "".join(s.split())
    target = norm(snippet)
    symbol_table = run_codeanalyzer_on_file(file_path)
    key = get_best_key(symbol_table, file_path)
    mod = symbol_table.get(key)
    if not mod:
        return f"<ERROR>Could not locate module info for `{file_path}`.</ERROR>"

    hits = []

    for fn in mod.get("functions", {}).values():
        if target in norm(fn["code"]):
            hits.append((fn["code"], fn["start_line"], fn["end_line"], fn["name"]))

    for cls in mod.get("classes", {}).values():
        for mname, m in cls.get("methods", {}).items():
            if target in norm(m["code"]):
                hits.append((m["code"], m["start_line"], m["end_line"], f"{cls['name']}.{mname}"))

    if not hits:
        return f"<ERROR>No code matches found in `{file_path.name}` for the given snippet.</ERROR>"

    return "\n\n".join(format_code_block(code, start, end, descriptor=name) for code, start, end, name in hits)


# ---------------------------------------------------------------------------
# Utility: Run codeanalyzer on a single file with caching
# ---------------------------------------------------------------------------
def run_codeanalyzer_on_file(file_path: Path) -> Dict[str, Any]:
    file_path = file_path.resolve()
    file_hash = hashlib.sha256(file_path.read_bytes()).hexdigest()
    mtime = file_path.stat().st_mtime
    project_root = file_path.parent
    output_dir = project_root / ".codeanalyzer_output_single"
    output_dir.mkdir(exist_ok=True)

    default_json = output_dir / "analysis.json"
    out_file = output_dir / f"{file_path.stem}_analysis.json"

    if out_file.exists():
        data = json.loads(out_file.read_text())
        symbol_table = data.get("symbol_table", {})
        key = get_best_key(symbol_table, file_path)
        mod = symbol_table.get(key)
        if mod.get("content_hash") == file_hash:
            return symbol_table

    try:
        subprocess.run([
            "codeanalyzer",
            "--input", str(project_root),
            "--file-name", str(file_path),
            "--analysis-level", "1",
            "--output", str(output_dir),
            "--format", "json"
        ], capture_output=True, text=True, check=True)
        print(f"<INFO>Code analysis completed for {file_path}.</INFO>")
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"<ERROR>codeanalyzer failed:\nSTDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}")

    if not default_json.exists():
        raise RuntimeError(f"<ERROR>Expected analysis output not found: {default_json}</ERROR>")

    default_json.rename(out_file)
    return json.loads(out_file.read_text()).get("symbol_table", {})


def get_best_key(symbol_table: Dict[str, Any], file_path: Path) -> str:
    candidates = [k for k in symbol_table if k.endswith(file_path.name)]
    return candidates[0] if candidates else file_path.name


# ---------------------------------------------------------------------------
# Utility: Format code block with line numbers
# ---------------------------------------------------------------------------
def format_code_block(code: str, start: int, end: int, descriptor: str) -> str:
    if len(code) > MAX_RESPONSE_LEN:
        code = code[:MAX_RESPONSE_LEN] + "\n" + TRUNCATED_MESSAGE
    numbered = "\n".join(f"{i+start:6}\t{ln}" for i, ln in enumerate(code.splitlines()))
    return f"Definition for `{descriptor}` (lines {start}-{end}):\n" + numbered


# ---------------------------------------------------------------------------
# CLI wrapper
# ---------------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="structure-aware search tool")
    parser.add_argument("command", choices=["find_file", "search_entity", "find_code"], help="Sub-command")
    parser.add_argument("value", help="Target to search for (file name, entity, or snippet)")
    parser.add_argument("--path", type=str, default=".", help="Root search directory")
    parser.add_argument("--file", type=str, help="File to operate on (for entity/snippet)")
    args = parser.parse_args()

    root = Path(args.path).resolve()
    if not root.exists():
        print(f"<ERROR>Invalid path: {root}</ERROR>")
        sys.exit(1)

    if args.command == "find_file":
        print(find_file(args.value, root))
    else:
        if not args.file:
            print("<ERROR>`--file` is required for this operation.</ERROR>")
            sys.exit(2)
        file_path = root / args.file
        if not file_path.exists():
            print(f"<ERROR>File not found: {file_path}</ERROR>")
            sys.exit(3)
        try:
            if args.command == "search_entity":
                print(search_entity(file_path, args.value))
            else:
                print(find_code(file_path, args.value))
        except RuntimeError as err:
            print(err)
            sys.exit(4)


if __name__ == "__main__":
    main()