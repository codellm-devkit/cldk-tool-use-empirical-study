{
  "directed": true,
  "multigraph": true,
  "graph": {
    "resolution_status": "unresolved",
    "instance_name": "pydata__xarray-4094",
    "difficulty": "<15 min fix",
    "golden_patch_difficulty": "easy",
    "golden_files_change": 1,
    "patch_difficulty": "medium",
    "files_change": 2
  },
  "nodes": [
    {
      "label": "cd",
      "args": [
        "/workspace/pydata__xarray__0.12"
      ],
      "phase": "general",
      "step_indices": [
        0,
        1,
        6,
        7,
        11,
        13,
        23,
        25
      ],
      "id": "0:cd"
    },
    {
      "label": "pytest",
      "args": [],
      "phase": "general",
      "step_indices": [
        0
      ],
      "id": "1:pytest"
    },
    {
      "label": "grep",
      "args": [
        "."
      ],
      "phase": "general",
      "step_indices": [
        1,
        6
      ],
      "id": "2:grep"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          1000,
          1100
        ]
      },
      "phase": "localization",
      "step_indices": [
        2
      ],
      "id": "3:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          1500,
          1600
        ]
      },
      "phase": "localization",
      "step_indices": [
        3
      ],
      "id": "4:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          2000,
          2100
        ]
      },
      "phase": "localization",
      "step_indices": [
        4
      ],
      "id": "5:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          2500,
          -1
        ]
      },
      "phase": "localization",
      "step_indices": [
        5
      ],
      "id": "6:str_replace_editor\nview"
    },
    {
      "label": "grep",
      "args": [
        "xarray/core/dataarray.py"
      ],
      "phase": "general",
      "step_indices": [
        7
      ],
      "id": "7:grep"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          1900,
          1950
        ]
      },
      "phase": "localization",
      "step_indices": [
        8
      ],
      "id": "8:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\ncreate",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/tests/test_unstack_single_dim.py",
        "file_text": "\nimport numpy as np\nimport xarray as xr\n\ndef test_unstack_single_dim():\n    \"\"\"Test that to_unstacked_dataset works with single-dim variables.\"\"\"\n    arr = xr.DataArray(\n        np.arange(3),\n        coords=[(\"x\", [0, 1, 2])],\n    )\n    data = xr.Dataset({\"a\": arr, \"b\": arr})\n    stacked = data.to_stacked_array('y', sample_dims=['x'])\n    unstacked = stacked.to_unstacked_dataset('y')\n    xr.testing.assert_identical(data, unstacked)\n"
      },
      "phase": "verification",
      "step_indices": [
        9
      ],
      "id": "9:str_replace_editor\ncreate"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a\n        stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n        label : int, default 0\n            Label of the level to expand dataset along. Overrides the label\n            argument if given.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> data\n        <xarray.Dataset>\n        Dimensions:  (x: 2, y: 3)\n        Coordinates:\n          * x        (x) <U1 'a' 'b'\n          * y        (y) int64 0 1 2\n        Data variables:\n            a        (x, y) int64 0 1 2 3 4 5\n            b        (x) int64 0 3\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> stacked.indexes[\"z\"]\n        MultiIndex(levels=[['a', 'b'], [0, 1, 2]],\n                labels=[[0, 0, 0, 1], [0, 1, 2, -1]],\n                names=['variable', 'y'])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n",
        "new_str": "\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a\n        stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n        label : int, default 0\n            Label of the level to expand dataset along. Overrides the label\n            argument if given.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> data\n        <xarray.Dataset>\n        Dimensions:  (x: 2, y: 3)\n        Coordinates:\n          * x        (x) <U1 'a' 'b'\n          * y        (y) int64 0 1 2\n        Data variables:\n            a        (x, y) int64 0 1 2 3 4 5\n            b        (x) int64 0 3\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> stacked.indexes[\"z\"]\n        MultiIndex(levels=[['a', 'b'], [0, 1, 2]],\n                labels=[[0, 0, 0, 1], [0, 1, 2, -1]],\n                names=['variable', 'y'])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_name = index.names[level_num]\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            result[str(value)] = da\n\n        return Dataset(result)\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        10
      ],
      "id": "10:str_replace_editor\nstr_replace"
    },
    {
      "label": "pytest",
      "args": [
        "xarray/tests/test_unstack_single_dim.py"
      ],
      "phase": "general",
      "step_indices": [
        11,
        13,
        23,
        25
      ],
      "id": "11:pytest"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a\n        stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n        label : int, default 0\n            Label of the level to expand dataset along. Overrides the label\n            argument if given.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> data\n        <xarray.Dataset>\n        Dimensions:  (x: 2, y: 3)\n        Coordinates:\n          * x        (x) <U1 'a' 'b'\n          * y        (y) int64 0 1 2\n        Data variables:\n            a        (x, y) int64 0 1 2 3 4 5\n            b        (x) int64 0 3\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> stacked.indexes[\"z\"]\n        MultiIndex(levels=[['a', 'b'], [0, 1, 2]],\n                labels=[[0, 0, 0, 1], [0, 1, 2, -1]],\n                names=['variable', 'y'])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_name = index.names[level_num]\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            result[str(value)] = da\n\n        return Dataset(result)\n        \"\"\"\n\n",
        "new_str": "\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            result[str(value)] = da\n\n        return Dataset(result)\n\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        12
      ],
      "id": "12:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            result[str(value)] = da\n\n        return Dataset(result)\n\n\n",
        "new_str": "\n\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            # Remove conflicting coordinates before merging\n            da = da.reset_coords(drop=True)\n            result[str(value)] = da\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n\n",
        "edit_status": "failure: not found"
      },
      "phase": "patch",
      "step_indices": [
        14
      ],
      "id": "13:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            result[str(value)] = da\n\n        return Dataset(result)\n",
        "new_str": "\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            # Remove conflicting coordinates before merging\n            da = da.reset_coords(drop=True)\n            result[str(value)] = da\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        15
      ],
      "id": "14:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n        idx = self.indexes[dim]\n        if not isinstance(idx, pd.MultiIndex):\n            raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n\n\n",
        "new_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n",
        "edit_status": "failure: not found"
      },
      "phase": "patch",
      "step_indices": [
        16
      ],
      "id": "15:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n        idx = self.indexes[dim]\n        if not isinstance(idx, pd.MultiIndex):\n            raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n",
        "new_str": "\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        17
      ],
      "id": "16:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n        level_number = idx._get_level_number(level)\n        variables = idx.levels[level_number]\n        variable_dim = idx.names[level_number]\n\n\n",
        "new_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n",
        "edit_status": "failure: not found"
      },
      "phase": "patch",
      "step_indices": [
        18
      ],
      "id": "17:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nview",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "view_range": [
          1960,
          1970
        ]
      },
      "phase": "localization",
      "step_indices": [
        19
      ],
      "id": "18:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n        level_number = idx._get_level_number(level)\n        variables = idx.levels[level_number]\n        variable_dim = idx.names[level_number]\n\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n",
        "new_str": "\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        20
      ],
      "id": "19:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n        level_number = idx._get_level_number(level)\n        variables = idx.levels[level_number]\n        variable_dim = idx.names[level_number]\n\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # unstacked dataset\n        return Dataset(data_dict)\n\n\n",
        "new_str": "\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n\n",
        "edit_status": "failure: not found"
      },
      "phase": "patch",
      "step_indices": [
        21
      ],
      "id": "20:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
        "new_str": "\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        22
      ],
      "id": "21:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "args": {
        "path": "/workspace/pydata__xarray__0.12/xarray/core/dataarray.py",
        "old_str": "\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            # Remove conflicting coordinates before merging\n            da = da.reset_coords(drop=True)\n            result[str(value)] = da\n\n        # Reconstruct with original coordinates\n        unstacked = Dataset(result)\n        return unstacked.assign_coords(**self.coords)\n\n",
        "new_str": "\n\n    def to_unstacked_dataset(self, dim, level=0):\n        \"\"\"Unstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\n        This is the inverse operation of Dataset.to_stacked_array.\n\n        Parameters\n        ----------\n        dim : str\n            Name of existing dimension to unstack\n        level : int or str\n            The MultiIndex level to expand to a dataset along. Can either be\n            the integer index of the level or its name.\n\n        Returns\n        -------\n        unstacked: Dataset\n\n        Examples\n        --------\n        >>> import xarray as xr\n        >>> arr = xr.DataArray(\n        ...     np.arange(6).reshape(2, 3),\n        ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n        ... )\n        >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n        >>> stacked = data.to_stacked_array(\"z\", [\"y\"])\n        >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n        >>> data.identical(roundtripped)\n        True\n\n        See Also\n        --------\n        Dataset.to_stacked_array\n        \"\"\"\n        from .dataset import Dataset\n\n        if dim not in self.dims:\n            raise ValueError(f\"dimension {dim} does not exist\")\n\n        index = self.get_index(dim)\n        if not isinstance(index, pd.MultiIndex):\n            # Handle single-dimension case\n            if len(self.coords[dim].dims) == 1:\n                # For single-dim vars, return directly without stacking coordinates\n                return Dataset({self.name: self})\n            raise ValueError(f\"dimension {dim} has no MultiIndex\")\n\n        level_num = index._get_level_number(level)\n        level_values = index.levels[level_num]\n\n        result = {}\n        for value in level_values:\n            key = (value,) if level_num == 0 else (slice(None), value)\n            da = self.sel(**{dim: key})\n            if da.isnull().all():  # skip all-NaN slices\n                continue\n            # Remove all coordinates to avoid conflicts\n            da = da.reset_coords(drop=True)\n            result[str(value)] = da\n\n        # Reconstruct only non-stacked coordinates\n        unstacked = Dataset(result)\n        coords_to_keep = {k: v for k, v in self.coords.items() if dim not in v.dims}\n        return unstacked.assign_coords(**coords_to_keep)\n\n",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        24
      ],
      "id": "22:str_replace_editor\nstr_replace"
    }
  ],
  "edges": [
    {
      "label": "0",
      "type": "exec",
      "source": "0:cd",
      "target": "1:pytest",
      "key": 0
    },
    {
      "label": "1",
      "type": "exec",
      "source": "0:cd",
      "target": "2:grep",
      "key": 0
    },
    {
      "label": "6",
      "type": "exec",
      "source": "0:cd",
      "target": "2:grep",
      "key": 1
    },
    {
      "label": "7",
      "type": "exec",
      "source": "0:cd",
      "target": "7:grep",
      "key": 0
    },
    {
      "label": "11",
      "type": "exec",
      "source": "0:cd",
      "target": "11:pytest",
      "key": 0
    },
    {
      "label": "13",
      "type": "exec",
      "source": "0:cd",
      "target": "11:pytest",
      "key": 1
    },
    {
      "label": "23",
      "type": "exec",
      "source": "0:cd",
      "target": "11:pytest",
      "key": 2
    },
    {
      "label": "25",
      "type": "exec",
      "source": "0:cd",
      "target": "11:pytest",
      "key": 3
    },
    {
      "label": "1",
      "type": "exec",
      "source": "1:pytest",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "2",
      "type": "exec",
      "source": "2:grep",
      "target": "3:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "7",
      "type": "exec",
      "source": "2:grep",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "3",
      "type": "exec",
      "source": "3:str_replace_editor\nview",
      "target": "4:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "3:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "4",
      "type": "exec",
      "source": "4:str_replace_editor\nview",
      "target": "5:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "4:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "5",
      "type": "exec",
      "source": "5:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "5:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 1
    },
    {
      "label": "6",
      "type": "exec",
      "source": "6:str_replace_editor\nview",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "8",
      "type": "exec",
      "source": "7:grep",
      "target": "8:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "9",
      "type": "exec",
      "source": "8:str_replace_editor\nview",
      "target": "9:str_replace_editor\ncreate",
      "key": 0
    },
    {
      "type": "hier",
      "source": "8:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "10",
      "type": "exec",
      "source": "9:str_replace_editor\ncreate",
      "target": "10:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "11",
      "type": "exec",
      "source": "10:str_replace_editor\nstr_replace",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "12",
      "type": "exec",
      "source": "11:pytest",
      "target": "12:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "14",
      "type": "exec",
      "source": "11:pytest",
      "target": "13:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "24",
      "type": "exec",
      "source": "11:pytest",
      "target": "22:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "13",
      "type": "exec",
      "source": "12:str_replace_editor\nstr_replace",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "15",
      "type": "exec",
      "source": "13:str_replace_editor\nstr_replace",
      "target": "14:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "16",
      "type": "exec",
      "source": "14:str_replace_editor\nstr_replace",
      "target": "15:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "17",
      "type": "exec",
      "source": "15:str_replace_editor\nstr_replace",
      "target": "16:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "18",
      "type": "exec",
      "source": "16:str_replace_editor\nstr_replace",
      "target": "17:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "19",
      "type": "exec",
      "source": "17:str_replace_editor\nstr_replace",
      "target": "18:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "20",
      "type": "exec",
      "source": "18:str_replace_editor\nview",
      "target": "19:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "type": "hier",
      "source": "18:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "21",
      "type": "exec",
      "source": "19:str_replace_editor\nstr_replace",
      "target": "20:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "22",
      "type": "exec",
      "source": "20:str_replace_editor\nstr_replace",
      "target": "21:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "23",
      "type": "exec",
      "source": "21:str_replace_editor\nstr_replace",
      "target": "0:cd",
      "key": 0
    },
    {
      "label": "25",
      "type": "exec",
      "source": "22:str_replace_editor\nstr_replace",
      "target": "0:cd",
      "key": 0
    }
  ]
}