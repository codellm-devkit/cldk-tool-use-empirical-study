{
  "directed": true,
  "multigraph": true,
  "graph": {
    "resolution_status": "unresolved",
    "instance_name": "pytest-dev__pytest-7571",
    "difficulty": "15 min - 1 hour"
  },
  "nodes": [
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.18446403788402677
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed"
      },
      "phase": "localization",
      "step_indices": [
        0
      ],
      "id": "0:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.20777879003435373
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest"
      },
      "phase": "localization",
      "step_indices": [
        1
      ],
      "id": "1:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.2044296010863036
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py"
      },
      "phase": "localization",
      "step_indices": [
        2
      ],
      "id": "2:str_replace_editor\nview"
    },
    {
      "label": "echo",
      "execution_time": [
        0.1981472964398563,
        0.15788968745619059
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": [
        ">",
        "/testbed/reproduce_issue.py"
      ],
      "phase": "general",
      "step_indices": [
        3,
        14
      ],
      "id": "3:echo"
    },
    {
      "label": "python",
      "execution_time": [
        0.1981472964398563,
        0.3382128111552447,
        0.3298296669963747,
        0.331421836046502,
        0.15788968745619059,
        0.3110699539538473,
        0.2941393228247762,
        0.29061177815310657
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": [
        "/testbed/reproduce_issue.py"
      ],
      "phase": "verification",
      "step_indices": [
        3,
        8,
        10,
        12,
        14,
        16,
        18,
        20
      ],
      "id": "4:python"
    },
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.18918845197185874
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "view_range": [
          340,
          358
        ]
      },
      "phase": "localization",
      "step_indices": [
        4
      ],
      "id": "5:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.17297441512346268
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "view_range": [
          422,
          437
        ]
      },
      "phase": "localization",
      "step_indices": [
        5
      ],
      "id": "6:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nview",
      "execution_time": [
        0.18432385311461985
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "view_range": [
          461,
          475
        ]
      },
      "phase": "localization",
      "step_indices": [
        6
      ],
      "id": "7:str_replace_editor\nview"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.18189048301428556
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)",
        "new_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n        # restore handler level to default (NOTSET)\n        self.handler.setLevel(logging.NOTSET)",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        7
      ],
      "id": "8:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.1751469171140343
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n        # restore handler level to default (NOTSET)\n        self.handler.setLevel(logging.NOTSET)",
        "new_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        print(f\"DEBUG: _finalize called. Initial levels: {self._initial_logger_levels}\")\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            print(f\"DEBUG: Restoring logger {logger_name} to level {level}\")\n            logger.setLevel(level)\n        # restore handler level to default (NOTSET)\n        print(f\"DEBUG: Restoring handler level to NOTSET\")\n        self.handler.setLevel(logging.NOTSET)",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        9
      ],
      "id": "9:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.18635821994394064
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()",
        "new_str": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    print(\"DEBUG: caplog fixture setup\")\n    yield result\n    print(\"DEBUG: caplog fixture teardown\")\n    result._finalize()",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        11
      ],
      "id": "10:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.19427562900818884
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)",
        "new_str": "    @contextmanager\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> Generator[None, None, None]:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value when the context exits.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it later\n        original_level = logger_obj.level\n        self._initial_logger_levels.setdefault(logger, original_level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(original_level)\n            self.handler.setLevel(logging.NOTSET)",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        13
      ],
      "id": "11:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.20065636397339404
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "    @contextmanager\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> Generator[None, None, None]:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value when the context exits.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it later\n        original_level = logger_obj.level\n        self._initial_logger_levels.setdefault(logger, original_level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(original_level)\n            self.handler.setLevel(logging.NOTSET)",
        "new_str": "    @contextmanager\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> Generator[None, None, None]:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value when the context exits.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it later\n        original_level = logger_obj.level\n        self._initial_logger_levels.setdefault(logger, original_level)\n        print(f\"DEBUG: Setting level for logger {logger} to {level} (original: {original_level})\")\n        logger_obj.setLevel(level)\n        print(f\"DEBUG: Setting handler level to {level}\")\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            print(f\"DEBUG: Restoring logger {logger} to level {original_level}\")\n            logger_obj.setLevel(original_level)\n            print(f\"DEBUG: Restoring handler level to NOTSET\")\n            self.handler.setLevel(logging.NOTSET)",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        15
      ],
      "id": "12:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.18355723889544606
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    print(\"DEBUG: caplog fixture setup\")\n    yield result\n    print(\"DEBUG: caplog fixture teardown\")\n    result._finalize()",
        "new_str": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    try:\n        yield result\n    finally:\n        result._finalize()",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        17
      ],
      "id": "13:str_replace_editor\nstr_replace"
    },
    {
      "label": "str_replace_editor\nstr_replace",
      "execution_time": [
        0.19778769579716027
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {
        "path": "/testbed/src/_pytest/logging.py",
        "old_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        print(f\"DEBUG: _finalize called. Initial levels: {self._initial_logger_levels}\")\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            print(f\"DEBUG: Restoring logger {logger_name} to level {level}\")\n            logger.setLevel(level)\n        # restore handler level to default (NOTSET)\n        print(f\"DEBUG: Restoring handler level to NOTSET\")\n        self.handler.setLevel(logging.NOTSET)",
        "new_str": "    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n        # reset handler level to NOTSET\n        self.handler.setLevel(logging.NOTSET)\n        # clear the initial levels to avoid redundant restorations\n        self._initial_logger_levels.clear()",
        "edit_status": "success"
      },
      "phase": "patch",
      "step_indices": [
        19
      ],
      "id": "14:str_replace_editor\nstr_replace"
    },
    {
      "label": "submit",
      "execution_time": [
        0.20086553297005594,
        0.20311982580460608
      ],
      "state": {
        "working_dir": "/testbed"
      },
      "args": {},
      "phase": "submit",
      "step_indices": [
        21,
        23
      ],
      "id": "15:submit"
    },
    {
      "label": "empty action",
      "execution_time": [
        0.0
      ],
      "state": {},
      "args": {},
      "phase": "general",
      "step_indices": [
        22
      ],
      "id": "16:empty action"
    }
  ],
  "edges": [
    {
      "label": "1",
      "type": "exec",
      "source": "0:str_replace_editor\nview",
      "target": "1:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "0:str_replace_editor\nview",
      "target": "1:str_replace_editor\nview",
      "key": 1
    },
    {
      "label": "2",
      "type": "exec",
      "source": "1:str_replace_editor\nview",
      "target": "2:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "1:str_replace_editor\nview",
      "target": "2:str_replace_editor\nview",
      "key": 1
    },
    {
      "label": "3",
      "type": "exec",
      "source": "2:str_replace_editor\nview",
      "target": "3:echo",
      "key": 0
    },
    {
      "type": "hier",
      "source": "2:str_replace_editor\nview",
      "target": "5:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "2:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "type": "hier",
      "source": "2:str_replace_editor\nview",
      "target": "7:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "3",
      "type": "exec",
      "source": "3:echo",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "14",
      "type": "exec",
      "source": "3:echo",
      "target": "4:python",
      "key": 1
    },
    {
      "label": "4",
      "type": "exec",
      "source": "4:python",
      "target": "5:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "9",
      "type": "exec",
      "source": "4:python",
      "target": "9:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "11",
      "type": "exec",
      "source": "4:python",
      "target": "10:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "13",
      "type": "exec",
      "source": "4:python",
      "target": "11:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "15",
      "type": "exec",
      "source": "4:python",
      "target": "12:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "17",
      "type": "exec",
      "source": "4:python",
      "target": "13:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "19",
      "type": "exec",
      "source": "4:python",
      "target": "14:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "21",
      "type": "exec",
      "source": "4:python",
      "target": "15:submit",
      "key": 0
    },
    {
      "label": "5",
      "type": "exec",
      "source": "5:str_replace_editor\nview",
      "target": "6:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "6",
      "type": "exec",
      "source": "6:str_replace_editor\nview",
      "target": "7:str_replace_editor\nview",
      "key": 0
    },
    {
      "label": "7",
      "type": "exec",
      "source": "7:str_replace_editor\nview",
      "target": "8:str_replace_editor\nstr_replace",
      "key": 0
    },
    {
      "label": "8",
      "type": "exec",
      "source": "8:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "10",
      "type": "exec",
      "source": "9:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "12",
      "type": "exec",
      "source": "10:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "14",
      "type": "exec",
      "source": "11:str_replace_editor\nstr_replace",
      "target": "3:echo",
      "key": 0
    },
    {
      "label": "16",
      "type": "exec",
      "source": "12:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "18",
      "type": "exec",
      "source": "13:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "20",
      "type": "exec",
      "source": "14:str_replace_editor\nstr_replace",
      "target": "4:python",
      "key": 0
    },
    {
      "label": "22",
      "type": "exec",
      "source": "15:submit",
      "target": "16:empty action",
      "key": 0
    },
    {
      "label": "23",
      "type": "exec",
      "source": "16:empty action",
      "target": "15:submit",
      "key": 0
    }
  ]
}