#!/usr/bin/env python3
"""Structural Searcher Tool
================================================
Structure-aware search utility for SWE-Agent.

API Calls
---------
1. search_entity: search for a class/function/method across the entire repository.
2. find_code: locate function/method blocks that contain a code snippet across the repo.
3. search_entity_in_file: search for an entity in a specific file.
4. find_code_in_file: search for code snippet matches in a specific file.

Relies on `codeanalyzer` output from precomputed analysis.json files.
"""

from __future__ import annotations

import argparse
import hashlib
import json
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List

MAX_RESPONSE_LEN = 16000
TRUNCATED_MESSAGE = (
    "<response clipped><NOTE>To save on context, only part of the code has been "
    "shown. Use `str_replace_editor view --view_range` to inspect full block.</NOTE>"
)

# ---------------------------------------------------------------------------
# Shared Utility: Load symbol table from project-wide analysis
# ---------------------------------------------------------------------------
def run_codeanalyzer(project_root: str, output_dir: str) -> bool:
    try:
        result = subprocess.run(
            [
                "codeanalyzer",
                "--input", project_root,
                "--analysis-level", "1",
                "--output", output_dir,
                "--format", "json"
            ],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        return True
    except subprocess.CalledProcessError as e:
        print(f"<ERROR> Codeanalyzer failed.\nSTDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}")
        return False

def load_project_symbol_table(project_path: Path) -> Dict[str, Any]:
    output_file = project_path / ".codeanalyzer_output" / "analysis.json"
    success = run_codeanalyzer(str(project_path), str(project_path / ".codeanalyzer_output"))

    if not success or not output_file.exists():
        raise RuntimeError("<ERROR>Symbol table not found or failed to generate.")
    try:
        return json.loads(output_file.read_text()).get("symbol_table", {})
    except json.JSONDecodeError as e:
        raise RuntimeError(f"<ERROR>Failed to parse symbol table: {e}")


# ---------------------------------------------------------------------------
# Shared Utility: Format code block with line numbers
# ---------------------------------------------------------------------------
def format_code_block(code: str, start: int, end: int, descriptor: str) -> str:
    if len(code) > MAX_RESPONSE_LEN:
        code = code[:MAX_RESPONSE_LEN] + "\n" + TRUNCATED_MESSAGE
    numbered = "\n".join(f"{i+start:6}\t{ln}" for i, ln in enumerate(code.splitlines()))
    return f"Definition for `{descriptor}` (lines {start}-{end}):\n" + numbered


def format_class_signature(cls: dict) -> str:
    lines = [f"Class `{cls['name']}`:", f"  Signature: {cls.get('signature', '<no signature>')}\n"]
    methods = cls.get("methods", {})
    if methods:
        lines.append("  Member Methods:")
        for mname, method in methods.items():
            sig = method.get("signature") or f"def {mname}(...)"
            lines.append(f"    - {sig}")
    else:
        lines.append("  No methods defined.")
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# API: search_entity
# ---------------------------------------------------------------------------
def search_entity(project_path: Path, entity: str) -> str:
    try:
        table = load_project_symbol_table(project_path)
    except Exception as e:
        return str(e)

    results = []
    for file, module in table.items():
        for fn in module.get("functions", {}).values():
            if fn["name"] == entity:
                results.append((file, fn, entity))
        for cls in module.get("classes", {}).values():
            if cls["name"] == entity:
                results.append((file, cls, "class_signature"))
            for mname, m in cls.get("methods", {}).items():
                if entity in {mname, f"{cls['name']}.{mname}"}:
                    results.append((file, m, f"{cls['name']}.{mname}"))

    if not results:
        return f"<ERROR>Entity `{entity}` not found in project."

    return "\n\n".join(
        f"[{file}]\n" +
        (format_code_block(node["code"], node["start_line"], node["end_line"], ent)
         if ent != "class_signature" else format_class_signature(node))
        for file, node, ent in results
    )


# ---------------------------------------------------------------------------
# API: find_code
# ---------------------------------------------------------------------------
def find_code(project_path: Path, snippet: str) -> str:
    norm = lambda s: "".join(s.split())
    target = norm(snippet)
    try:
        table = load_project_symbol_table(project_path)
    except Exception as e:
        return str(e)

    results = []
    for file, module in table.items():
        for fn in module.get("functions", {}).values():
            if target in norm(fn["code"]):
                results.append((file, fn["code"], fn["start_line"], fn["end_line"], fn["name"]))
        for cls in module.get("classes", {}).values():
            for mname, m in cls.get("methods", {}).items():
                if target in norm(m["code"]):
                    results.append((file, m["code"], m["start_line"], m["end_line"], f"{cls['name']}.{mname}"))

    if not results:
        return "<ERROR>No match for snippet found in project."

    return "\n\n".join(f"[{f}]\n" + format_code_block(code, s, e, name) for f, code, s, e, name in results)


# ---------------------------------------------------------------------------
# API: search_entity_in_file
# ---------------------------------------------------------------------------
def search_entity_in_file(file_path: Path, entity: str) -> str:
    table = run_codeanalyzer_on_single_file(file_path)
    key = get_best_key(table, file_path)
    mod = table.get(key, {})
    if not mod:
        return f"<ERROR>No data for `{file_path.name}`."

    for fn in mod.get("functions", {}).values():
        if fn["name"] == entity:
            return format_code_block(fn["code"], fn["start_line"], fn["end_line"], entity)

    for cls in mod.get("classes", {}).values():
        if cls["name"] == entity:
            return format_class_signature(cls)
        for mname, m in cls.get("methods", {}).items():
            if mname == entity or f"{cls['name']}.{mname}" == entity:
                return format_code_block(m["code"], m["start_line"], m["end_line"], f"{cls['name']}.{mname}")

    return f"<ERROR>Entity `{entity}` not found in `{file_path.name}`."


# ---------------------------------------------------------------------------
# API: find_code_in_file
# ---------------------------------------------------------------------------
def find_code_in_file(file_path: Path, snippet: str) -> str:
    norm = lambda s: "".join(s.split())
    target = norm(snippet)
    table = run_codeanalyzer_on_single_file(file_path)
    key = get_best_key(table, file_path)
    mod = table.get(key, {})
    if not mod:
        return f"<ERROR>No data for `{file_path.name}`."

    results = []
    for fn in mod.get("functions", {}).values():
        if target in norm(fn["code"]):
            results.append((fn["code"], fn["start_line"], fn["end_line"], fn["name"]))
    for cls in mod.get("classes", {}).values():
        for mname, m in cls.get("methods", {}).items():
            if target in norm(m["code"]):
                results.append((m["code"], m["start_line"], m["end_line"], f"{cls['name']}.{mname}"))

    if not results:
        return f"<ERROR>No snippet match in `{file_path.name}`."

    return "\n\n".join(format_code_block(code, start, end, desc) for code, start, end, desc in results)


# ---------------------------------------------------------------------------
# Internal: Single-file codeanalyzer runner
# ---------------------------------------------------------------------------
def run_codeanalyzer_on_single_file(file_path: Path) -> Dict[str, Any]:
    output_dir = file_path.parent / ".codeanalyzer_output_single"
    output_dir.mkdir(exist_ok=True)
    default_output = output_dir / "analysis.json"
    custom_output = output_dir / f"{file_path.stem}_analysis.json"

    try:
        subprocess.run([
            "codeanalyzer",
            "--input", str(file_path.parent),
            "--file-name", str(file_path),
            "--analysis-level", "1",
            "--output", str(output_dir),
            "--format", "json"
        ], capture_output=True, text=True, check=True)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"<ERROR>codeanalyzer failed:\nSTDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}")

    if default_output.exists():
        default_output.rename(custom_output)
    if not custom_output.exists():
        raise RuntimeError(f"<ERROR>Expected output missing: {custom_output}")
    return json.loads(custom_output.read_text()).get("symbol_table", {})


def get_best_key(symbol_table: Dict[str, Any], file_path: Path) -> str:
    candidates = [k for k in symbol_table if k.endswith(file_path.name)]
    return candidates[0] if candidates else file_path.name


# ---------------------------------------------------------------------------
# CLI wrapper (optional for manual testing)
# ---------------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="Structural search tool for Python codebases")
    parser.add_argument("command", choices=[
        "search_entity", "find_code", "search_entity_in_file", "find_code_in_file"])
    parser.add_argument("target", help="Entity name or snippet")
    parser.add_argument("--project", type=str, default="/testbed", help="Root directory for analysis")
    parser.add_argument("--file_path", type=str, help="Specific file path (for single file commands)")
    args = parser.parse_args()

    if args.command in {"search_entity", "find_code"}:
        func = search_entity if args.command == "search_entity" else find_code
        print(func(Path(args.project), args.target))
    else:
        if not args.file_path:
            print("<ERROR>--file_path required for file-level search.")
            sys.exit(1)
        func = search_entity_in_file if args.command == "search_entity_in_file" else find_code_in_file
        print(func(Path(args.file_path), args.target))


if __name__ == "__main__":
    main()
